// Code generated by protoc-gen-go. DO NOT EDIT.
// source: api/messages.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	_struct "github.com/golang/protobuf/ptypes/struct"
	status "google.golang.org/genproto/googleapis/rpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// A Ticket is a basic matchmaking entity in Open Match. In order to enter
// matchmaking using Open Match, the client should generate a Ticket, passing in
// the properties to be associated with this Ticket. Open Match will generate an
// ID for a Ticket during creation. A Ticket could be used to represent an
// individual 'Player' or a 'Group' of players. Open Match will not interpret
// what the Ticket represents but just treat it as a matchmaking unit with a set
// of properties. Open Match stores the Ticket in state storage and enables an
// Assignment to be associated with this Ticket.
type Ticket struct {
	// The Ticket ID generated by Open Match.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Properties contains custom info about the ticket.  Top level values can be
	// used in indexing and filtering to find tickets.
	Properties *_struct.Struct `protobuf:"bytes,2,opt,name=properties,proto3" json:"properties,omitempty"`
	// Assignment associated with the Ticket.
	Assignment           *Assignment `protobuf:"bytes,3,opt,name=assignment,proto3" json:"assignment,omitempty"`
	Details              *any.Any    `protobuf:"bytes,4,opt,name=details,proto3" json:"details,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Ticket) Reset()         { *m = Ticket{} }
func (m *Ticket) String() string { return proto.CompactTextString(m) }
func (*Ticket) ProtoMessage()    {}
func (*Ticket) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{0}
}

func (m *Ticket) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ticket.Unmarshal(m, b)
}
func (m *Ticket) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ticket.Marshal(b, m, deterministic)
}
func (m *Ticket) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ticket.Merge(m, src)
}
func (m *Ticket) XXX_Size() int {
	return xxx_messageInfo_Ticket.Size(m)
}
func (m *Ticket) XXX_DiscardUnknown() {
	xxx_messageInfo_Ticket.DiscardUnknown(m)
}

var xxx_messageInfo_Ticket proto.InternalMessageInfo

func (m *Ticket) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Ticket) GetProperties() *_struct.Struct {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Ticket) GetAssignment() *Assignment {
	if m != nil {
		return m.Assignment
	}
	return nil
}

func (m *Ticket) GetDetails() *any.Any {
	if m != nil {
		return m.Details
	}
	return nil
}

// An Assignment object represents the assignment associated with a Ticket. Open
// match does not require or inspect any fields on assignment.
type Assignment struct {
	// Connection information for this Assignment.
	Connection string `protobuf:"bytes,1,opt,name=connection,proto3" json:"connection,omitempty"`
	// Other details to be sent to the players.
	Properties *_struct.Struct `protobuf:"bytes,2,opt,name=properties,proto3" json:"properties,omitempty"`
	// Error when finding an Assignment for this Ticket.
	Error                *status.Status `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Assignment) Reset()         { *m = Assignment{} }
func (m *Assignment) String() string { return proto.CompactTextString(m) }
func (*Assignment) ProtoMessage()    {}
func (*Assignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{1}
}

func (m *Assignment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Assignment.Unmarshal(m, b)
}
func (m *Assignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Assignment.Marshal(b, m, deterministic)
}
func (m *Assignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Assignment.Merge(m, src)
}
func (m *Assignment) XXX_Size() int {
	return xxx_messageInfo_Assignment.Size(m)
}
func (m *Assignment) XXX_DiscardUnknown() {
	xxx_messageInfo_Assignment.DiscardUnknown(m)
}

var xxx_messageInfo_Assignment proto.InternalMessageInfo

func (m *Assignment) GetConnection() string {
	if m != nil {
		return m.Connection
	}
	return ""
}

func (m *Assignment) GetProperties() *_struct.Struct {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Assignment) GetError() *status.Status {
	if m != nil {
		return m.Error
	}
	return nil
}

// Filters numerical values to only those within a range.
//   attribute: "foo"
//   max: 10
//   min: 5
// matches:
//   {"foo": 5}
//   {"foo": 7.5}
//   {"foo": 10}
// does not match:
//   {"foo": 4}
//   {"foo": 10.01}
//   {"foo": "7.5"}
//   {"foo": true}
//   {"foo": [7.5]}
//   {"foo": null}
//   {}
type FloatRangeFilter struct {
	// Name of the ticket attribute this Filter operates on.
	Attribute string `protobuf:"bytes,1,opt,name=attribute,proto3" json:"attribute,omitempty"`
	// Maximum value. Defaults to positive infinity (any value above minv).
	Max float64 `protobuf:"fixed64,2,opt,name=max,proto3" json:"max,omitempty"`
	// Minimum value. Defaults to 0.
	Min                  float64  `protobuf:"fixed64,3,opt,name=min,proto3" json:"min,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FloatRangeFilter) Reset()         { *m = FloatRangeFilter{} }
func (m *FloatRangeFilter) String() string { return proto.CompactTextString(m) }
func (*FloatRangeFilter) ProtoMessage()    {}
func (*FloatRangeFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{2}
}

func (m *FloatRangeFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FloatRangeFilter.Unmarshal(m, b)
}
func (m *FloatRangeFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FloatRangeFilter.Marshal(b, m, deterministic)
}
func (m *FloatRangeFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FloatRangeFilter.Merge(m, src)
}
func (m *FloatRangeFilter) XXX_Size() int {
	return xxx_messageInfo_FloatRangeFilter.Size(m)
}
func (m *FloatRangeFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_FloatRangeFilter.DiscardUnknown(m)
}

var xxx_messageInfo_FloatRangeFilter proto.InternalMessageInfo

func (m *FloatRangeFilter) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *FloatRangeFilter) GetMax() float64 {
	if m != nil {
		return m.Max
	}
	return 0
}

func (m *FloatRangeFilter) GetMin() float64 {
	if m != nil {
		return m.Min
	}
	return 0
}

// Filters boolean values.
//   attribute: "foo"
//   value: false
// matches:
//   {"foo": false}
// does not match:
//   {"foo": true}
//   {"foo": "bar"}
//   {"foo": 1}
//   {"foo": "false"}
//   {"foo": [false]}
//   {"foo": null}
//   {}
type BoolEqualsFilter struct {
	Attribute            string   `protobuf:"bytes,1,opt,name=attribute,proto3" json:"attribute,omitempty"`
	Value                bool     `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BoolEqualsFilter) Reset()         { *m = BoolEqualsFilter{} }
func (m *BoolEqualsFilter) String() string { return proto.CompactTextString(m) }
func (*BoolEqualsFilter) ProtoMessage()    {}
func (*BoolEqualsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{3}
}

func (m *BoolEqualsFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BoolEqualsFilter.Unmarshal(m, b)
}
func (m *BoolEqualsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BoolEqualsFilter.Marshal(b, m, deterministic)
}
func (m *BoolEqualsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BoolEqualsFilter.Merge(m, src)
}
func (m *BoolEqualsFilter) XXX_Size() int {
	return xxx_messageInfo_BoolEqualsFilter.Size(m)
}
func (m *BoolEqualsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_BoolEqualsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_BoolEqualsFilter proto.InternalMessageInfo

func (m *BoolEqualsFilter) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *BoolEqualsFilter) GetValue() bool {
	if m != nil {
		return m.Value
	}
	return false
}

// Filters strings exactly equaling a value.
//   attribute: "foo"
//   value: "bar"
// matches:
//   {"foo": "bar"}
// does not match:
//   {"foo": "baz"}
//   {"foo": true}
//   {"foo": 5}
//   {"foo": ["bar"]}
//   {"foo": null}
//   {}
type StringEqualsFilter struct {
	Attribute            string   `protobuf:"bytes,1,opt,name=attribute,proto3" json:"attribute,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringEqualsFilter) Reset()         { *m = StringEqualsFilter{} }
func (m *StringEqualsFilter) String() string { return proto.CompactTextString(m) }
func (*StringEqualsFilter) ProtoMessage()    {}
func (*StringEqualsFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{4}
}

func (m *StringEqualsFilter) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StringEqualsFilter.Unmarshal(m, b)
}
func (m *StringEqualsFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StringEqualsFilter.Marshal(b, m, deterministic)
}
func (m *StringEqualsFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringEqualsFilter.Merge(m, src)
}
func (m *StringEqualsFilter) XXX_Size() int {
	return xxx_messageInfo_StringEqualsFilter.Size(m)
}
func (m *StringEqualsFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_StringEqualsFilter.DiscardUnknown(m)
}

var xxx_messageInfo_StringEqualsFilter proto.InternalMessageInfo

func (m *StringEqualsFilter) GetAttribute() string {
	if m != nil {
		return m.Attribute
	}
	return ""
}

func (m *StringEqualsFilter) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

type Pool struct {
	// A developer-chosen human-readable name for this Pool.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Set of Filters indicating the filtering criteria. Selected players must
	// match every Filter.
	FloatRangeFilters    []*FloatRangeFilter   `protobuf:"bytes,2,rep,name=float_range_filters,json=floatRangeFilters,proto3" json:"float_range_filters,omitempty"`
	BoolEqualsFilters    []*BoolEqualsFilter   `protobuf:"bytes,3,rep,name=bool_equals_filters,json=boolEqualsFilters,proto3" json:"bool_equals_filters,omitempty"`
	StringEqualsFilters  []*StringEqualsFilter `protobuf:"bytes,4,rep,name=string_equals_filters,json=stringEqualsFilters,proto3" json:"string_equals_filters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Pool) Reset()         { *m = Pool{} }
func (m *Pool) String() string { return proto.CompactTextString(m) }
func (*Pool) ProtoMessage()    {}
func (*Pool) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{5}
}

func (m *Pool) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Pool.Unmarshal(m, b)
}
func (m *Pool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Pool.Marshal(b, m, deterministic)
}
func (m *Pool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pool.Merge(m, src)
}
func (m *Pool) XXX_Size() int {
	return xxx_messageInfo_Pool.Size(m)
}
func (m *Pool) XXX_DiscardUnknown() {
	xxx_messageInfo_Pool.DiscardUnknown(m)
}

var xxx_messageInfo_Pool proto.InternalMessageInfo

func (m *Pool) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Pool) GetFloatRangeFilters() []*FloatRangeFilter {
	if m != nil {
		return m.FloatRangeFilters
	}
	return nil
}

func (m *Pool) GetBoolEqualsFilters() []*BoolEqualsFilter {
	if m != nil {
		return m.BoolEqualsFilters
	}
	return nil
}

func (m *Pool) GetStringEqualsFilters() []*StringEqualsFilter {
	if m != nil {
		return m.StringEqualsFilters
	}
	return nil
}

// A Roster is a named collection of Ticket IDs. It exists so that a Tickets
// associated with a Match can be labelled to belong to a team, sub-team etc. It
// can also be used to represent the current state of a Match in scenarios such
// as backfill, join-in-progress etc.
type Roster struct {
	// A developer-chosen human-readable name for this Roster.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Tickets belonging to this Roster.
	TicketIds            []string `protobuf:"bytes,2,rep,name=ticket_ids,json=ticketIds,proto3" json:"ticket_ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Roster) Reset()         { *m = Roster{} }
func (m *Roster) String() string { return proto.CompactTextString(m) }
func (*Roster) ProtoMessage()    {}
func (*Roster) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{6}
}

func (m *Roster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Roster.Unmarshal(m, b)
}
func (m *Roster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Roster.Marshal(b, m, deterministic)
}
func (m *Roster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Roster.Merge(m, src)
}
func (m *Roster) XXX_Size() int {
	return xxx_messageInfo_Roster.Size(m)
}
func (m *Roster) XXX_DiscardUnknown() {
	xxx_messageInfo_Roster.DiscardUnknown(m)
}

var xxx_messageInfo_Roster proto.InternalMessageInfo

func (m *Roster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Roster) GetTicketIds() []string {
	if m != nil {
		return m.TicketIds
	}
	return nil
}

// A MatchProfile is Open Match's representation of a Match specification. It is
// used to indicate the criteria for selecting players for a match. A
// MatchProfile is the input to the API to get matches and is passed to the
// MatchFunction. It contains all the information required by the MatchFunction
// to generate match proposals.
type MatchProfile struct {
	// Name of this match profile.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Set of properties associated with this MatchProfile. (Optional)
	// Open Match does not interpret these properties but passes them through to
	// the MatchFunction.
	Properties *_struct.Struct `protobuf:"bytes,2,opt,name=properties,proto3" json:"properties,omitempty"`
	// Set of pools to be queried when generating a match for this MatchProfile.
	// The pool names can be used in empty Rosters to specify composition of a
	// match.
	Pools []*Pool `protobuf:"bytes,3,rep,name=pools,proto3" json:"pools,omitempty"`
	// Set of Rosters for this match request. Could be empty Rosters used to
	// indicate the composition of the generated Match or they could be partially
	// pre-populated Ticket list to be used in scenarios such as backfill / join
	// in progress.
	Rosters              []*Roster `protobuf:"bytes,4,rep,name=rosters,proto3" json:"rosters,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *MatchProfile) Reset()         { *m = MatchProfile{} }
func (m *MatchProfile) String() string { return proto.CompactTextString(m) }
func (*MatchProfile) ProtoMessage()    {}
func (*MatchProfile) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{7}
}

func (m *MatchProfile) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MatchProfile.Unmarshal(m, b)
}
func (m *MatchProfile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MatchProfile.Marshal(b, m, deterministic)
}
func (m *MatchProfile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MatchProfile.Merge(m, src)
}
func (m *MatchProfile) XXX_Size() int {
	return xxx_messageInfo_MatchProfile.Size(m)
}
func (m *MatchProfile) XXX_DiscardUnknown() {
	xxx_messageInfo_MatchProfile.DiscardUnknown(m)
}

var xxx_messageInfo_MatchProfile proto.InternalMessageInfo

func (m *MatchProfile) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MatchProfile) GetProperties() *_struct.Struct {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *MatchProfile) GetPools() []*Pool {
	if m != nil {
		return m.Pools
	}
	return nil
}

func (m *MatchProfile) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

// A Match is used to represent a completed match object. It can be generated by
// a MatchFunction as a proposal or can be returned by OpenMatch as a result in
// response to the FetchMatches call.
// When a match is returned by the FetchMatches call, it should contain at least
// one ticket to be considered as valid.
type Match struct {
	// A Match ID that should be passed through the stack for tracing.
	MatchId string `protobuf:"bytes,1,opt,name=match_id,json=matchId,proto3" json:"match_id,omitempty"`
	// Name of the match profile that generated this Match.
	MatchProfile string `protobuf:"bytes,2,opt,name=match_profile,json=matchProfile,proto3" json:"match_profile,omitempty"`
	// Name of the match function that generated this Match.
	MatchFunction string `protobuf:"bytes,3,opt,name=match_function,json=matchFunction,proto3" json:"match_function,omitempty"`
	// Tickets belonging to this match.
	Tickets []*Ticket `protobuf:"bytes,4,rep,name=tickets,proto3" json:"tickets,omitempty"`
	// Set of Rosters that comprise this Match
	Rosters []*Roster `protobuf:"bytes,5,rep,name=rosters,proto3" json:"rosters,omitempty"`
	// Match properties for this Match. Open Match does not interpret this field.
	Properties           *_struct.Struct `protobuf:"bytes,6,opt,name=properties,proto3" json:"properties,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Match) Reset()         { *m = Match{} }
func (m *Match) String() string { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()    {}
func (*Match) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb9fb1f207fd5b8c, []int{8}
}

func (m *Match) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Match.Unmarshal(m, b)
}
func (m *Match) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Match.Marshal(b, m, deterministic)
}
func (m *Match) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Match.Merge(m, src)
}
func (m *Match) XXX_Size() int {
	return xxx_messageInfo_Match.Size(m)
}
func (m *Match) XXX_DiscardUnknown() {
	xxx_messageInfo_Match.DiscardUnknown(m)
}

var xxx_messageInfo_Match proto.InternalMessageInfo

func (m *Match) GetMatchId() string {
	if m != nil {
		return m.MatchId
	}
	return ""
}

func (m *Match) GetMatchProfile() string {
	if m != nil {
		return m.MatchProfile
	}
	return ""
}

func (m *Match) GetMatchFunction() string {
	if m != nil {
		return m.MatchFunction
	}
	return ""
}

func (m *Match) GetTickets() []*Ticket {
	if m != nil {
		return m.Tickets
	}
	return nil
}

func (m *Match) GetRosters() []*Roster {
	if m != nil {
		return m.Rosters
	}
	return nil
}

func (m *Match) GetProperties() *_struct.Struct {
	if m != nil {
		return m.Properties
	}
	return nil
}

func init() {
	proto.RegisterType((*Ticket)(nil), "openmatch.Ticket")
	proto.RegisterType((*Assignment)(nil), "openmatch.Assignment")
	proto.RegisterType((*FloatRangeFilter)(nil), "openmatch.FloatRangeFilter")
	proto.RegisterType((*BoolEqualsFilter)(nil), "openmatch.BoolEqualsFilter")
	proto.RegisterType((*StringEqualsFilter)(nil), "openmatch.StringEqualsFilter")
	proto.RegisterType((*Pool)(nil), "openmatch.Pool")
	proto.RegisterType((*Roster)(nil), "openmatch.Roster")
	proto.RegisterType((*MatchProfile)(nil), "openmatch.MatchProfile")
	proto.RegisterType((*Match)(nil), "openmatch.Match")
}

func init() { proto.RegisterFile("api/messages.proto", fileDescriptor_cb9fb1f207fd5b8c) }

var fileDescriptor_cb9fb1f207fd5b8c = []byte{
	// 617 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xcf, 0x4e, 0xdc, 0x3c,
	0x14, 0xc5, 0x95, 0xf9, 0x07, 0xb9, 0xf0, 0xf1, 0x81, 0x01, 0x31, 0x50, 0xa8, 0x50, 0x2a, 0xa4,
	0x91, 0xaa, 0x26, 0x12, 0x55, 0xd5, 0x45, 0x57, 0x20, 0x75, 0x54, 0x54, 0x55, 0xa5, 0x86, 0x55,
	0x37, 0x23, 0x4f, 0xe2, 0x49, 0x2d, 0x12, 0xdb, 0xb5, 0x1d, 0x54, 0x96, 0x5d, 0x75, 0xd9, 0xf7,
	0xe8, 0xa6, 0xdb, 0x3e, 0x5e, 0x15, 0x3b, 0x19, 0xa2, 0x0c, 0x52, 0xd1, 0xec, 0xe2, 0x7b, 0x8f,
	0x7f, 0xbe, 0xe7, 0xc4, 0x09, 0x20, 0x22, 0x59, 0x94, 0x53, 0xad, 0x49, 0x4a, 0x75, 0x28, 0x95,
	0x30, 0x02, 0xf9, 0x42, 0x52, 0x9e, 0x13, 0x13, 0x7f, 0x39, 0xd8, 0x4b, 0x85, 0x48, 0x33, 0x1a,
	0x29, 0x19, 0x47, 0xda, 0x10, 0x53, 0x54, 0x9a, 0x83, 0xfd, 0xaa, 0x61, 0x57, 0xd3, 0x62, 0x16,
	0x11, 0x7e, 0x57, 0xb5, 0x0e, 0xdb, 0x2d, 0x6d, 0x54, 0x11, 0x1b, 0xd7, 0x0d, 0xfe, 0x78, 0x30,
	0xb8, 0x66, 0xf1, 0x0d, 0x35, 0x68, 0x03, 0x3a, 0x2c, 0x19, 0x7a, 0xc7, 0xde, 0xc8, 0xc7, 0x1d,
	0x96, 0xa0, 0xd7, 0x00, 0x52, 0x09, 0x49, 0x95, 0x61, 0x54, 0x0f, 0x3b, 0xc7, 0xde, 0x68, 0xed,
	0x74, 0x2f, 0x74, 0xb4, 0xb0, 0xa6, 0x85, 0x57, 0x96, 0x86, 0x1b, 0x52, 0xf4, 0x0a, 0x80, 0x68,
	0xcd, 0x52, 0x9e, 0x53, 0x6e, 0x86, 0x5d, 0xbb, 0x71, 0x37, 0x9c, 0xbb, 0x08, 0xcf, 0xe6, 0x4d,
	0xdc, 0x10, 0xa2, 0x10, 0x56, 0x12, 0x6a, 0x08, 0xcb, 0xf4, 0xb0, 0x67, 0xf7, 0xec, 0x2c, 0x1c,
	0x76, 0xc6, 0xef, 0x70, 0x2d, 0x0a, 0x7e, 0x7a, 0x00, 0xf7, 0x28, 0xf4, 0x14, 0x20, 0x16, 0x9c,
	0xd3, 0xd8, 0x30, 0xc1, 0x2b, 0x1b, 0x8d, 0xca, 0xf2, 0x76, 0x46, 0xd0, 0xa7, 0x4a, 0x09, 0x55,
	0x39, 0x41, 0xf5, 0x1e, 0x25, 0xe3, 0xf0, 0xca, 0xbe, 0x04, 0xec, 0x04, 0xc1, 0x35, 0x6c, 0x8e,
	0x33, 0x41, 0x0c, 0x26, 0x3c, 0xa5, 0x63, 0x96, 0x19, 0xaa, 0xd0, 0x21, 0xf8, 0xc4, 0x18, 0xc5,
	0xa6, 0x85, 0xa1, 0xd5, 0x54, 0xf7, 0x05, 0xb4, 0x09, 0xdd, 0x9c, 0x7c, 0xb3, 0xd3, 0x78, 0xb8,
	0x7c, 0xb4, 0x15, 0xc6, 0xed, 0x59, 0x65, 0x85, 0xf1, 0x60, 0x0c, 0x9b, 0xe7, 0x42, 0x64, 0x6f,
	0xbf, 0x16, 0x24, 0xd3, 0x8f, 0xa2, 0xee, 0x40, 0xff, 0x96, 0x64, 0x05, 0xb5, 0xdc, 0x55, 0xec,
	0x16, 0xc1, 0x3b, 0x40, 0x57, 0x46, 0x31, 0x9e, 0x2e, 0x4b, 0xf2, 0x6b, 0xd2, 0x8f, 0x0e, 0xf4,
	0x2e, 0x85, 0xc8, 0x10, 0x82, 0x1e, 0x27, 0x79, 0xbd, 0xcf, 0x3e, 0xa3, 0xf7, 0xb0, 0x3d, 0x2b,
	0x43, 0x98, 0xa8, 0x32, 0x85, 0xc9, 0xcc, 0x1e, 0x53, 0x06, 0xde, 0x1d, 0xad, 0x9d, 0x3e, 0x69,
	0x5c, 0x83, 0x76, 0x54, 0x78, 0x6b, 0xd6, 0xaa, 0xe8, 0x12, 0x36, 0x15, 0x22, 0x9b, 0x50, 0x3b,
	0xf2, 0x1c, 0xd6, 0x5d, 0x80, 0xb5, 0x13, 0xc2, 0x5b, 0xd3, 0x56, 0x45, 0xa3, 0x4f, 0xb0, 0xab,
	0x6d, 0x00, 0x6d, 0x5c, 0xcf, 0xe2, 0x8e, 0x1a, 0xb8, 0xc5, 0xa0, 0xf0, 0xb6, 0x5e, 0xa8, 0xe9,
	0xe0, 0x0d, 0x0c, 0xb0, 0xd0, 0x65, 0x8e, 0x0f, 0x45, 0x71, 0x04, 0x60, 0xec, 0xb7, 0x35, 0x61,
	0x89, 0x4b, 0xc0, 0xc7, 0xbe, 0xab, 0x5c, 0x24, 0x3a, 0xf8, 0xed, 0xc1, 0xfa, 0x87, 0xf2, 0xb8,
	0x4b, 0x25, 0x66, 0x2c, 0xa3, 0x0f, 0x32, 0x96, 0xbe, 0xb6, 0x27, 0xd0, 0x97, 0x42, 0x64, 0x75,
	0x58, 0xff, 0x37, 0xdc, 0x95, 0xef, 0x0e, 0xbb, 0x2e, 0x7a, 0x0e, 0x2b, 0xca, 0x3a, 0xa8, 0x63,
	0xd8, 0x6a, 0x08, 0x9d, 0x37, 0x5c, 0x2b, 0x82, 0xef, 0x1d, 0xe8, 0xdb, 0x89, 0xd1, 0x3e, 0xac,
	0x5a, 0xc9, 0x64, 0xfe, 0xcb, 0x58, 0xb1, 0xeb, 0x8b, 0x04, 0x3d, 0x83, 0xff, 0x5c, 0x4b, 0x3a,
	0x5b, 0xd5, 0xdd, 0x59, 0xcf, 0x9b, 0x56, 0x4f, 0x60, 0xc3, 0x89, 0x66, 0x05, 0x77, 0x5f, 0x6c,
	0xd7, 0xaa, 0xdc, 0xd6, 0x71, 0x55, 0x2c, 0xa7, 0x73, 0x79, 0x3d, 0x34, 0x9d, 0xfb, 0x6f, 0xe1,
	0x5a, 0xd1, 0xb4, 0xd2, 0xff, 0x97, 0x95, 0x56, 0xae, 0x83, 0x47, 0xe7, 0x7a, 0x1e, 0x7e, 0x3e,
	0x2e, 0xa9, 0x2f, 0x1c, 0x36, 0xa1, 0xb7, 0xd1, 0xfd, 0x32, 0x92, 0x37, 0x69, 0x24, 0xa7, 0xbf,
	0x3a, 0xfe, 0x47, 0x49, 0xb9, 0x4d, 0x6a, 0x3a, 0xb0, 0xb0, 0x97, 0x7f, 0x03, 0x00, 0x00, 0xff,
	0xff, 0x53, 0x69, 0x94, 0x60, 0xdb, 0x05, 0x00, 0x00,
}
