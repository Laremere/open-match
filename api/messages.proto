// Copyright 2019 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
package api;
option go_package = "internal/future/pb";

// // A Ticket is a basic matchmaking entity in Open Match. In order to enter
// // matchmaking using Open Match, the client should generate a Ticket, passing in
// // the properties to be associated with this Ticket. Open Match will generate an
// // ID for a Ticket during creation. A Ticket could be used to represent an
// // individual 'Player' or a 'Group' of players. Open Match will not interpret
// // what the Ticket represents but just treat it as a matchmaking unit with a set
// // of properties. Open Match stores the Ticket in state storage and enables an
// // Assignment to be associated with this Ticket.
// message Ticket {
//   // The Ticket ID generated by Open Match.
//   string id = 1;

//   // JSON string for properties associated with this Ticket. A subset of these
//   // properties will be indexed based on the indexing configuration.
//   string properties = 2;

//   // Assignment associated with the Ticket.
//   Assignment assignment = 3;
// }

// // An Assignment object represents the assignment associated with a Ticket.
// message Assignment {
//   // Connection information for this Assignment.
//   string connection = 1;

//   // Other details to be sent to the players. (Optional)
//   // Open Match does not interpret these properties.
//   string properties = 2;

//   // Error when finding an Assignment for this Ticket.
//   string error = 3;
// }

// // A hard filter used to query a subset of Tickets meeting the filtering
// // criteria.
// message Filter {
//   // Name of the ticket attribute this Filter operates on.
//   string attribute = 1;

//   // Maximum value. Defaults to positive infinity (any value above minv).
//   double max = 2;

//   // Minimum value. Defaults to 0.
//   double min = 3;
// }

// message Pool {
//   // A developer-chosen human-readable name for this Pool.
//   string name = 1;

//   // Set of Filters indicating the filtering criteria. Selected players must
//   // match every Filter.
//   repeated Filter filter = 2;
// }

// // A Roster is a named collection of Ticket IDs. It exists so that a Tickets
// // associated with a Match can be labelled to belong to a team, sub-team etc. It
// // can also be used to represent the current state of a Match in scenarios such
// // as backfill, join-in-progress etc.
// message Roster {
//   // A developer-chosen human-readable name for this Roster.
//   string name = 1;

//   // Tickets belonging to this Roster.
//   repeated string ticket_id = 2;
// }

// // A MatchProfile is Open Match's representation of a Match specification. It is
// // used to indicate the criteria for selecting players for a match. A
// // MatchProfile is the input to the API to get matches and is passed to the
// // MatchFunction. It contains all the information required by the MatchFunction
// // to generate match proposals.
// message MatchProfile {
//   // Name of this match profile.
//   string name = 1;

//   // Set of properties associated with this MatchProfile. (Optional)
//   // Open Match does not interpret these properties but passes them through to
//   // the MatchFunction.
//   string properties = 2;

//   // Set of pools to be queried when generating a match for this MatchProfile.
//   // The pool names can be used in empty Rosters to specify composition of a
//   // match.
//   repeated Pool pool = 3;

//   // Set of Rosters for this match request. Could be empty Rosters used to
//   // indicate the composition of the generated Match or they could be partially
//   // pre-populated Ticket list to be used in scenarios such as backfill / join
//   // in progress.
//   repeated Roster roster = 4;
// }

// // A Match is used to represent a completed match object. It can be generated by
// // a MatchFunction as a proposal or can be returned by OpenMatch as a result in
// // response to the GetMatches call.
// message Match {
//   // A Match ID that should be passed through the stack for tracing.
//   string match_id = 1;

//   // Name of the match profile that generated this Match.
//   string match_profile = 2;

//   // Name of the match function that generated this Match.
//   string match_function = 3;

//   // Tickets belonging to this match.
//   repeated Ticket ticket = 4;

//   // Set of Rosters that comprise this Match
//   repeated Roster roster = 5;

//   // Match properties for this Match. Open Match does not interpret this field.
//   string properties = 6;
// }


//////////////////////////////////////////////
//////////////////////////////////////////////


import "google/protobuf/any.proto";

message Ticket {
  string id = 1;

  google.protobuf.Any properties = 2;

  map<string, double> dargs = 3;

  // If this is removed, Ticket becomes immutable in the system.
  // Assignment assignment = 4;
}

message Assignment {
  string connection = 1;
  google.protobuf.Any properties = 2;
  string error = 3;
}

//////////////////////////////////////////////
//////////////////////////////////////////////

message Index {
  oneof value {
    PoolIndex pool_index = 1;
    RangeIndex range_index = 2;
    // QuadIndex quad_index = 3;
    // OctIndex oct_index = 4;
    // Add index for direct id lookup?
  }
}

message PoolIndex {
  Index index = 1;
  repeated Filter filters = 2;
}

message RangeIndex {
  string darg = 1;
}

// message QuadIndex {
//   string darg0 = 1;
//   string darg1 = 2;
//
//   double min0 = 3;
//   double min1 = 4;
//
//   double max0 = 5;
//   double max1 = 6;
// }
//
// message OctIndex {
//   string darg0 = 1;
//   string darg1 = 2;
//   string darg2 = 3;
//
//   double min0 = 4;
//   double min1 = 5;
//   double min2 = 6;
//
//   double max0 = 7;
//   double max1 = 8;
//   double max2 = 9;
// }

//////////////////////////////////////////////
//////////////////////////////////////////////

message Filter {
  oneof value {
    RangeFilter range_filter = 1;
  }
}

message RangeFilter {
  string darg = 1;
  double min = 2;
  double max = 3;
}

// Also doable:
// - distance
// - taxicab distance

//////////////////////////////////////////////
//////////////////////////////////////////////

message Query {
  Index index = 1;
  repeated Filter filters = 2;
}
